1,"select cycleRootId, snapnum, min (elementId) as elementId from CycleEdges_SD1 group by cycleRootId, snapnum) , -- calculate CoM position of element pos as (select ce.cycleRootId, ce.snapnum, ce.elementId , avg (cast (n.x as float) ) as x, avg (cast (n.y as float) ) as y from ce, FragData.directedEdges_SD1 e , FragData.nodes_SD1 n where e.snapnum = ce.snapnum and e.elementId = ce.elementId and n.nodeid = e.node1 and n.snapnum = ce.snapnum group by ce.cycleRootId, ce.snapnum, ce.elementId) -- Calculate various properties of cycle -- #. rotationAngle from CoM position. -- If ~#Pi -> element inside cycle, if ~#, outside -- #. area (from http://mathinsight.org/greens_theorem_find_area -- applied to linesegments -- #. Circumeference: simple sum of length of edges -- #/#/#/#. Min/max X, Y (only node1 required as all nodes show up -- once as node1, once as node2 -- #. Count (*) : number of edges in cycle select pos.cycleRootId, pos.snapnum , sum (atn2 (( (n1.x-pos.x) * (n2.y-pos.y) - (n1.y-pos.y) * (n2.x-pos.x) ), ( (n1.x-pos.x) * (n2.x-pos.x) + (n1.y-pos.y) * (n2.y-pos.y) )) ) as rotationAngle , sum (n1.x*n2.y-n1.y*n2.x) as area , sum (sqrt ((n2.x-n1.x) * (n2.x-n1.x) + (n2.y-n1.y) * (n2.y-n1.y) )) as circumference , min (n1.x) as xmin, min (n1.y) as ymin , max (n1.x) as xmax, max (n1.y) as ymax , count (*) as numEdges into Cycles_SD1 from pos , cycleEdges_SD1 ce , FragData.DirectedEdges_SD1 de , FragData.nodes_SD1 n1 , FragData.nodes_SD1 n2 where ce.cycleRootId = pos.cycleRootId and ce.snapnum = pos.snapnum and de.elementId = ce.elementId and de.snapnum = ce.snapnum and de.edgeRank = ce.edgeRank and n1.nodeId = de.node1 and n1.snapnum = de.snapnum and n2.nodeId = de.node2 and n2.snapnum = de.snapnum group by pos.cycleRootId, pos.snapnum"
2019-01-20 09:35:00,1
